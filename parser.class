
declare -r _ARG_THIS_="${0}"
declare -r -i _VERBOSETY_LEVEL_LOW_=0
declare -r -i _VERBOSETY_LEVEL_HIGH_=1
declare -r -i _VERBOSETY_LEVEL_ULTRA_=2
declare -r -i _TOKEN_NO_NONE_=-1
declare -r -i _TOKEN_TYPE_=0
declare -r -i _TOKEN_VALUE_=1
declare -r _EMPTY_TOKEN_=''
declare -r _NO_VALUE_=''
declare -r _CLEAR_=''
declare -r _TOKEN_TYPE_NONE_=''
declare -r _SYMBOL_TOKEN_='symbol'
declare -r _STRING_TOKEN_='string'
declare -r _NUMBER_TOKEN_='number'
declare -r _OPERATION_TOKEN_='operation'
declare -r _SPACE_=' '
declare -r _SPACE_CLASS_='[[:space:]]'
declare -r _AMPERSAND_='&'
declare -r _NEWLINE_='\n'
declare -r _CARRIAGE_RETURN_='\r'
declare -r _CHAR_PIPE_='|'
declare -r _SEMICOLON_=';'
declare -r _COLON_=':'
declare -r _PLUS_SIGN_='+'
declare -r _MINUS_SIGN_='-'
declare -r _EQUAL_SIGN_='='
declare -r _DOT_='.'
declare -r _COMMA_=','
declare -r _PARAN_OPEN_='('
declare -r _PARAN_CLOSE_=')'
declare -r _QUOTE_="'"
declare -r _DOUBLE_QUOTE_='"'
declare -r _CURLY_OPEN_='{'
declare -r _CURLY_CLOSE_='}'
declare -r _MUL_='*'
declare -r _DIV_='/'
declare -r _ESC_TAB_='\t'
declare -r _TAB_='	'
declare -r _PATTERN_NUMBER_STARTS_WITH_DIGIT_='(^([[:digit:]])*([.][[:digit:]]){,1}([[:digit:]])*)'
declare -r _PATTERN_NUMBER_STARTS_WITH_DOT_='[0-9]+'
declare -r _PATTERN_NUMBER_SLOPPY_='[-+0-9.]*'
declare -r _PATTERN_ALPHA_='^(([[:alpha:]]+)([[:alnum:][_])*)'



#! Class named "parser" for bash Object
#! @see parser.h for constructor
# property
obj_properties=()

obj_tokens=()

obj_map_to_type=
obj_map_to_value=
obj_token_at=()



obj.read_token () {
   echo "obj.read_token"
   ORIG_IFS="$IFS"
   IFS=$'\n'
   set +o errexit 
   read -d "" -r -a  obj_tokens< $(obj.filename)
   set -o errexit
   IFS="$ORIG_IFS"
}


obj.unwrap_token () {
   declare -A obj_map_to_type
   declare -A obj_map_to_value
   AMOUNT_OF_TOKEN=${#obj_tokens}
   echo "AMOUNT_OF_TOKEN = ${AMOUNT_OF_TOKEN}"
   for (( no=0; 
          no < $(( $AMOUNT_OF_TOKEN )); 
          no++ )); do
      declare unwrap_token_buff=${obj_tokens[no]:0:-1}
      obj_token_at[no]="${unwrap_token_buff}"
      declare unwrap_token_stripped_buff="${unwrap_token_buff:1:-1}"
      declare unwrap_token_tab_buff=${unwrap_token_stripped_buff/${_COMMA_}${_SPACE_}/${_TAB_}} #OK
      #if [[ ${_VERBOSETY_LEVEL_ULTRA_} -lt ${OPT_VERBOSETY_LEVEL} ]]; then
      if [[ true ]]; then
         echo "--- token #[${no}]"
         echo "unwrap_token_buff          = »${unwrap_token_buff}« [${#unwrap_token_buff}]"
         echo "unwrap_token_stripped_buff =  »${unwrap_token_stripped_buff}« [${#unwrap_token_stripped_buff}]"
         echo "unwrap_token_tab_buff      =  »${unwrap_token_tab_buff/${_TAB_}/${_ESC_TAB_}}«  [${#unwrap_token_tab_buff}]"
      fi
      ORIG_IFS="${IFS}"
      IFS=$'\t'
      set +o errexit # don't stop on 'newlines'
         read -d '\t' -a unwrap_token_type_value_pair <<< "${unwrap_token_tab_buff}" # -d '' works like a charm, but with exit code (1)?!
      set -o errexit
      IFS="${ORIG_IFS}"
      declare unwrap_token_type="${unwrap_token_type_value_pair[${_TOKEN_TYPE_}]:1:-1}"   # unquote
      declare unwrap_token_value="${unwrap_token_type_value_pair[${_TOKEN_VALUE_}]:1:-2}" # unquote un[[:space:]]
      #if [[ ${_VERBOSETY_LEVEL_HIGH_} -lt ${OPT_VERBOSETY_LEVEL} ]]; then
      if [[ true ]]; then
         echo "unwrap_token_type          = »${unwrap_token_type}«" 
         echo "unwrap_token_value         = »${unwrap_token_value}«" 
      fi
      obj_map_to_type["${unwrap_token_buff}"]="${unwrap_token_type}"
      obj_map_to_value["${unwrap_token_buff}"]="${unwrap_token_value}"
   done
   #if [[ ${_VERBOSETY_LEVEL_ULTRA_} -lt ${OPT_VERBOSETY_LEVEL} ]]; then
   if [[ true ]]; then
      echo "obj_map_to_type"
      for token in "${!obj_map_to_type[@]}"; do
         echo -n "type: »${obj_map_to_type[$token]}«"
         echo "${_TAB_}token  : »$token"
      done
      echo "obj_map_to_value"
      for token in "${!obj_map_to_value[@]}"; do
         echo "token  : »$token«"
         echo "value: »${obj_map_to_value[$token]}«"
      done
   fi
}



# properties IDs
self=0
filename=1
stop_at=2
fail_if_at_end=4

obj.to_string() {
    for obj_index in ${!obj_properties[@]}; do echo "index [${obj_index}] '${obj_properties[${obj_index}]}'"; done
}

obj.tokens_to_string() {
    for obj_index in ${!obj_tokens[@]}; do echo "index [${obj_index}] '${obj_tokens[${obj_index}]}'"; done
}

obj.property(){
    set +u
    if [ "$2" == "=" ]
    then
	obj_properties[$1]=$3
    else
	echo ${obj_properties[$1]}
    fi
    set -u
}

obj.self(){
    set +u
    if [ "$1" == "=" ]
    then
        if [[ ${obj_properties[${2}]} ]]; then echo "self is an imutable property!"; return ; fi
	    obj.property self = $2
    else
	obj.property self
    fi
    set -u
}

obj.filename(){
    set +u
    if [ "$1" == "=" ]
    then
	obj.property filename = $2
    else
	obj.property filename
    fi
    set -u
}

obj.stop_at(){
    set +u
    if [ "$1" == "=" ]
    then
	obj.property stop_at = $2
    else
	obj.property stop_at
    fi
    set -u
}

obj.fail_if_at_end() {
    set +u
    if [ "$1" == "=" ]
    then
	obj.property fail_if_at_end = $2
    else
	obj.property fail_if_at_end
    fi
    set -u
}

obj.token.next(){
    return
}

obj.token.move_next (){
    return
}

obj.next_expression(){
    return
}

obj.multiple_expression(){
    return
}
